/**
 * ECharts mini for WeChat Mini Program
 * Simplified version specifically for health tracking visualizations
 */

// echarts-mini.js
(function (global) {
  var echarts = {};

  // Default styles for charts
  var DEFAULT_THEME = {
    color: [
      '#5470c6',
      '#91cc75',
      '#fac858',
      '#ee6666',
      '#73c0de',
      '#3ba272',
      '#fc8452',
      '#9a60b4',
      '#ea7ccc'
    ],
    backgroundColor: 'transparent',
    textStyle: {},
    title: {
      textStyle: {
        color: '#464646'
      },
      subtextStyle: {
        color: '#6E7079'
      }
    },
    line: {
      itemStyle: {
        borderWidth: 1
      },
      lineStyle: {
        width: 2
      },
      symbolSize: 4,
      symbol: 'emptyCircle',
      smooth: false
    },
    bar: {
      itemStyle: {
        barBorderWidth: 0,
        barBorderColor: '#ccc'
      }
    },
    legend: {
      textStyle: {
        color: '#333333'
      }
    },
    tooltip: {
      axisPointer: {
        lineStyle: {
          color: '#cccccc',
          width: 1
        },
        crossStyle: {
          color: '#cccccc',
          width: 1
        }
      }
    },
    grid: {
      left: '3%',
      right: '4%',
      bottom: '3%',
      containLabel: true
    },
    categoryAxis: {
      axisLine: {
        show: true,
        lineStyle: {
          color: '#6E7079'
        }
      },
      axisTick: {
        show: false,
        lineStyle: {
          color: '#6E7079'
        }
      },
      axisLabel: {
        show: true,
        color: '#6E7079'
      },
      splitLine: {
        show: false,
        lineStyle: {
          color: ['#E0E6F1']
        }
      },
      splitArea: {
        show: false
      }
    },
    valueAxis: {
      axisLine: {
        show: false,
        lineStyle: {
          color: '#6E7079'
        }
      },
      axisTick: {
        show: false,
        lineStyle: {
          color: '#6E7079'
        }
      },
      axisLabel: {
        show: true,
        color: '#6E7079'
      },
      splitLine: {
        show: true,
        lineStyle: {
          color: ['#E0E6F1']
        }
      },
      splitArea: {
        show: false
      }
    }
  };

  // Chart class for rendering visualizations
  function Chart(canvas, opts) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.opts = Object.assign({}, DEFAULT_THEME, opts || {});
    this.option = null;
    this._initCanvas();
  }

  Chart.prototype = {
    constructor: Chart,

    _initCanvas: function() {
      var canvas = this.canvas;
      var opts = this.opts;
      
      // Set width and height if provided
      if (opts.width) canvas.width = opts.width;
      if (opts.height) canvas.height = opts.height;
      
      // Configure for retina displays
      var ratio = opts.devicePixelRatio || 1;
      canvas.width = canvas.width * ratio;
      canvas.height = canvas.height * ratio;
      this.ctx.scale(ratio, ratio);
    },

    setOption: function(option) {
      this.option = option;
      this._render();
      return this;
    },

    _render: function() {
      var ctx = this.ctx;
      var option = this.option;
      var canvas = this.canvas;
      
      if (!option) return;

      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw title
      if (option.title && option.title.text) {
        this._drawTitle(option.title);
      }
      
      // Draw chart based on type
      if (option.series && option.series.length > 0) {
        var series = option.series[0];
        if (series.type === 'line') {
          this._drawLineChart(option);
        } else if (series.type === 'bar') {
          this._drawBarChart(option);
        }
      }
    },

    _drawTitle: function(titleOption) {
      var ctx = this.ctx;
      var text = titleOption.text;
      var left = titleOption.left || 'center';
      
      ctx.save();
      ctx.font = '14px sans-serif';
      ctx.fillStyle = titleOption.textStyle && titleOption.textStyle.color || '#333';
      
      var x = 0;
      if (left === 'center') {
        x = this.canvas.width / 2;
        ctx.textAlign = 'center';
      } else if (left === 'right') {
        x = this.canvas.width - 10;
        ctx.textAlign = 'right';
      } else {
        x = 10;
        ctx.textAlign = 'left';
      }
      
      ctx.fillText(text, x, 20);
      ctx.restore();
    },

    _drawLineChart: function(option) {
      var ctx = this.ctx;
      var xAxis = option.xAxis;
      var yAxis = option.yAxis;
      var series = option.series[0];
      var data = series.data;
      
      if (!data || data.length === 0) return;
      
      // Calculate dimensions
      var chartWidth = this.canvas.width - 60;
      var chartHeight = this.canvas.height - 60;
      var chartX = 40;
      var chartY = 40;
      
      // Draw axes
      this._drawAxes(xAxis, yAxis, chartX, chartY, chartWidth, chartHeight);
      
      // Find min and max for y scale
      var min = yAxis.min !== undefined ? yAxis.min : Math.min.apply(null, data);
      var max = yAxis.max !== undefined ? yAxis.max : Math.max.apply(null, data) * 1.1;
      
      // Draw line
      ctx.save();
      ctx.beginPath();
      ctx.strokeStyle = series.itemStyle && series.itemStyle.color || this.opts.color[0];
      ctx.lineWidth = 2;
      
      for (var i = 0; i < data.length; i++) {
        var x = chartX + (i / (data.length - 1)) * chartWidth;
        var y = chartY + chartHeight - ((data[i] - min) / (max - min)) * chartHeight;
        
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          if (series.smooth) {
            // Simple curve
            var prevX = chartX + ((i - 1) / (data.length - 1)) * chartWidth;
            var prevY = chartY + chartHeight - ((data[i - 1] - min) / (max - min)) * chartHeight;
            var cp1x = prevX + (x - prevX) / 3;
            var cp2x = prevX + 2 * (x - prevX) / 3;
            ctx.bezierCurveTo(cp1x, prevY, cp2x, y, x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
      }
      
      ctx.stroke();
      
      // Draw points
      for (var i = 0; i < data.length; i++) {
        var x = chartX + (i / (data.length - 1)) * chartWidth;
        var y = chartY + chartHeight - ((data[i] - min) / (max - min)) * chartHeight;
        
        ctx.beginPath();
        ctx.fillStyle = series.itemStyle && series.itemStyle.color || this.opts.color[0];
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fill();
      }
      
      ctx.restore();
    },

    _drawBarChart: function(option) {
      var ctx = this.ctx;
      var xAxis = option.xAxis;
      var yAxis = option.yAxis;
      var series = option.series[0];
      var data = series.data;
      
      if (!data || data.length === 0) return;
      
      // Calculate dimensions
      var chartWidth = this.canvas.width - 60;
      var chartHeight = this.canvas.height - 60;
      var chartX = 40;
      var chartY = 40;
      
      // Draw axes
      this._drawAxes(xAxis, yAxis, chartX, chartY, chartWidth, chartHeight);
      
      // Find min and max for y scale
      var min = yAxis.min !== undefined ? yAxis.min : 0;
      var max = yAxis.max !== undefined ? yAxis.max : Math.max.apply(null, data) * 1.1;
      
      // Calculate bar width
      var barWidth = (chartWidth / data.length) * 0.6;
      var barSpacing = (chartWidth / data.length) * 0.4;
      
      // Draw bars
      ctx.save();
      
      for (var i = 0; i < data.length; i++) {
        var x = chartX + (i / data.length) * chartWidth + barSpacing / 2;
        var barHeight = ((data[i] - min) / (max - min)) * chartHeight;
        var y = chartY + chartHeight - barHeight;
        
        ctx.beginPath();
        ctx.fillStyle = series.itemStyle && series.itemStyle.color || this.opts.color[0];
        ctx.rect(x, y, barWidth, barHeight);
        ctx.fill();
      }
      
      ctx.restore();
    },

    _drawAxes: function(xAxis, yAxis, chartX, chartY, chartWidth, chartHeight) {
      var ctx = this.ctx;
      
      // Draw axes lines
      ctx.save();
      ctx.strokeStyle = '#E0E6F1';
      ctx.lineWidth = 1;
      
      // X-axis
      ctx.beginPath();
      ctx.moveTo(chartX, chartY + chartHeight);
      ctx.lineTo(chartX + chartWidth, chartY + chartHeight);
      ctx.stroke();
      
      // Y-axis
      ctx.beginPath();
      ctx.moveTo(chartX, chartY);
      ctx.lineTo(chartX, chartY + chartHeight);
      ctx.stroke();
      
      // Draw labels if data is provided
      if (xAxis && xAxis.data) {
        for (var i = 0; i < xAxis.data.length; i++) {
          var x = chartX + (i / (xAxis.data.length - 1)) * chartWidth;
          ctx.fillStyle = '#6E7079';
          ctx.textAlign = 'center';
          ctx.fillText(xAxis.data[i], x, chartY + chartHeight + 15);
        }
      }
      
      // Draw Y-axis labels
      if (yAxis) {
        var min = yAxis.min !== undefined ? yAxis.min : 0;
        var max = yAxis.max !== undefined ? yAxis.max : 100;
        var step = (max - min) / 5;
        
        for (var i = 0; i <= 5; i++) {
          var y = chartY + chartHeight - (i / 5) * chartHeight;
          var value = min + i * step;
          ctx.fillStyle = '#6E7079';
          ctx.textAlign = 'right';
          ctx.fillText(value.toFixed(1), chartX - 5, y + 3);
          
          // Grid lines
          if (i > 0) {
            ctx.beginPath();
            ctx.strokeStyle = '#E0E6F1';
            ctx.moveTo(chartX, y);
            ctx.lineTo(chartX + chartWidth, y);
            ctx.stroke();
          }
        }
      }
      
      ctx.restore();
    }
  };

  // Export init function for creating chart instances
  echarts.init = function(canvas, theme, opts) {
    // Configure options
    opts = opts || {};
    opts.devicePixelRatio = opts.devicePixelRatio || 1;
    opts.width = opts.width || canvas.width;
    opts.height = opts.height || canvas.height;
    
    // Create new chart instance
    var chart = new Chart(canvas, opts);
    
    return chart;
  };

  // Export echarts object
  global.echarts = echarts;
})(typeof window !== 'undefined' ? window : global);

module.exports = echarts; 